#!/usr/bin/env perl
use strict;
use warnings;

use Getopt::Long 2.24, qw( GetOptionsFromArray :config bundling no_ignore_case no_auto_abbrev require_order prefix_pattern=- );
use Fcntl qw( O_WRONLY O_CREAT O_EXCL );
use POSIX 'WNOHANG';
use IO::Select;
use IO::Socket;
use File::Temp 'tmpnam';

sub BLOCKSIZE () { 8192 }

sub parse_ssh_argv {
	my ( $argv_ref ) = @_;
	my @ssh_argv;

	my $binary_switch = sub { push @ssh_argv, '-'.shift, @_ };
	my  $unary_switch = sub { push @ssh_argv, '-'.shift };

	my @opt_spec = (
		( map {; "$_=s" => $binary_switch } split //, 'bcDeFIiLlmOopRSWw' ),
		( map {;  $_    => $unary_switch  } split //, '1246AaCfgKkMNnqsTtVvXxYy' ),
	);

	GetOptionsFromArray $argv_ref, @opt_spec or exit 1;
	push @ssh_argv, shift @$argv_ref if @$argv_ref; # the hostname
	GetOptionsFromArray $argv_ref, @opt_spec or exit 1 if @$argv_ref;

	return @ssh_argv;
}


my @ssh_argv = parse_ssh_argv \@ARGV;

my $listen = IO::Socket::INET->new(
	Listen    => 1,
	Proto     => 'tcp',
	LocalAddr => '127.0.0.1',
	LocalPort => 0,
	ReusePort => 1,
);

my $ctl_sock = tmpnam();

push @ssh_argv, -S => $ctl_sock;

my @agent = ( perl => -e => do { local $/; "'".<DATA>."'" }, '--' );

unshift @agent, '-t' if not @ARGV; # login shell requested
unshift @agent, -M => -R => '0:localhost:' . $listen->sockport;

pipe my $read_ssh_stderr, my $write_ssh_stderr
	or die "Couldn't create pipe: $!\n";

my $ssh_exit;

for ( fork ) {
	die "Coudldn't fork: $!\n" if not defined;
	if ( my $firstborn = $_ ) {
		$SIG{'CHLD'} = sub {
			my $child;
			do {
				$child = waitpid( -1, WNOHANG );
				$ssh_exit = $? >> 8 if $child == $firstborn;
			} while $child > 0;
		};
	}
	else {
		require IO::Handle;
		$write_ssh_stderr->autoflush(1);
		open STDERR, '>&=', $write_ssh_stderr or exit 255;
		exec { 'ssh' } ssh => @ssh_argv, @agent, @ARGV;
	}
}

<$read_ssh_stderr> =~ /^Allocated port (\d+) for remote forward to localhost:${\$listen->sockport}/
	or die "Couldn't parse remote port\n";

my $remote_port = $1;

<$read_ssh_stderr> =~ /^llssh fifo: (.+)/
	or die "Couldn't parse fifo path\n";

my $fifo = $1;

system ssh => @ssh_argv, "echo $remote_port > $fifo";

my $select = IO::Select->new( $listen, $read_ssh_stderr );

my %buf;
my %name;
my %outfh;

sub done {
	my ( $sock ) = @_;
	$select->remove( $sock );
	$sock->close;
	delete $outfh{ $sock };
	delete $buf{ $sock };
	delete $name{ $sock };
	no warnings 'exiting';
	next SOCK;
}

until ( defined $ssh_exit ) {
	my @ready = $select->can_read; # may return () if interrupted by SIGCHLD

	SOCK: for my $sock ( @ready ) {
		if ( $sock == $listen ) {
			my $new = $listen->accept;
			$select->add( $new );
			$buf{ $new } = '';
			next;
		}

		if ( $sock == $read_ssh_stderr ) {
			my $buf;
			1 while BLOCKSIZE == ( $sock->sysread( $buf, BLOCKSIZE, length $buf ) || 0 );
			print STDERR $buf;
			next;
		}

		for ( $buf{ $sock } ) {
			1 while BLOCKSIZE == ( $sock->sysread( $_, BLOCKSIZE, length ) || 0 );

			if ( !$outfh{ $sock } and s/\A([^\x{0}]+)\x{0}// ) {
				my $filename = $1;
				$filename =~ s!.*/!!;
				done $sock if not length $filename;
				substr $filename, 0, 0, '/tmp/';
				$name{ $sock } = $filename;
				sysopen $outfh{ $sock }, $filename, O_WRONLY|O_CREAT|O_EXCL
					or done $sock;
			}

			if ( my $fh = $outfh{ $sock } ) {
				print $fh $_;
				$_ = '';
			}
		}

		if ( $sock->eof ) {
			for ( fork ) { exec open => $name{ $sock } if defined and not $_ }
			done $sock;
		}
	}
}

exit $ssh_exit;

__END__
use strict;
use File::Temp "tmpnam";
use POSIX "mkfifo";

my $Couldnt = sprintf "Couldn%st", chr 39;

my $fifo = tmpnam();
mkfifo $fifo, 0600 or die "$Couldnt create fifo: $!\n";
print STDERR "ssh lifeline fifo: $fifo\n";
open my $pipe, "<", $fifo or die "$Couldnt open fifo: $!\n";
chomp( $ENV{"SSH_LIFELINE_PORT"} = <$pipe> );
close $pipe or die "$Couldnt close fifo: $!\n";
unlink $fifo or die "$Couldnt unlink fifo: $!\n";

exec { $ARGV[0] } @ARGV if @ARGV;

my $shell = +(getpwnam $ENV{USER})[8];
$shell =~ m!([^/]+)\z!;
exec { $shell } "-$1";
